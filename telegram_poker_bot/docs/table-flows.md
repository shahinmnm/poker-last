# Table lifecycle overview

## Current implementation snapshot
The mini-app currently offers three separate entry points for creating poker tables. The home screen's "Play with friends" shortcut and the lobby's "Create a private table" CTA both deep-link into the private-table flow, while the dedicated "Create game" page keeps a local draft without calling the API. On the backend the FastAPI `/tables` endpoint delegates to `shared.services.table_service.create_table_with_config`, which persists a `Table` row (including the `is_public` flag and serialized config) and returns hydrated metadata via `get_table_info`. Group invites are stored in `group_game_invites`, keyed by a generated `game_id` and linked to the creator and optional Telegram group. The poker game core lives in `game_core.TableManager`, but it is only exercised when processing actions; table creation and seating paths do not currently inform the runtime engine.

## Unified flow (target state)
All table creation CTAs should converge on a single client form that calls the backend `/tables` API with a structured payload specifying visibility (`public` or `private`) plus blinds, stack, max seats, and optional auto-seating for the host. The server will persist the table, invalidate lobby caches, and immediately bootstrap the game core runtime so both public and private tables share the same initialization path. Seating or leaving a table re-syncs the runtime snapshot to keep the PokerKit adapter authoritative. The lobby always lists public tables pulled from the same endpoint, while the create form surfaces a success summary (with invite context for private games) before offering a "Go to table" action. Public-table creation is therefore server-backed, instantly discoverable in the lobby, and wired to the same game core lifecycle as private tables.
